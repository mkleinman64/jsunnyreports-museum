package nl.mk.jsunnyreports.loaders.inverterdataloaders;

import java.io.File;


import java.io.IOException;


import java.text.ParseException;
import java.text.SimpleDateFormat;

import java.util.Calendar;
import java.util.Date;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import jxl.Cell;
import jxl.DateCell;
import jxl.Sheet;
import jxl.Workbook;

import jxl.read.biff.BiffException;

import nl.mk.jsunnyreports.common.Constants;
import nl.mk.jsunnyreports.common.settings.Settings;
import nl.mk.jsunnyreports.loaders.inverterdataloaders.filefilters.RegularExpressionFilenameFilter;
import nl.mk.jsunnyreports.loaders.inverterdataloaders.filefilters.StartsWithFilenameFilter;
import nl.mk.jsunnyreports.dataobjects.cache.Files;
import nl.mk.jsunnyreports.dataobjects.inverterdata.InverterData;
import nl.mk.jsunnyreports.dataobjects.processfiles.FileEntries;
import nl.mk.jsunnyreports.dataobjects.processfiles.FileEntry;
import nl.mk.jsunnyreports.interfaces.LoaderInterface;

import nl.mk.jsunnyreports.inverters.BaseInverter;

import nl.mk.jsunnyreports.inverters.SunnyDataControlXLSInverter;
import nl.mk.jsunnyreports.loaders.inverterdataloaders.filefilters.EndsWithFilenameFilter;
import nl.mk.jsunnyreports.loaders.inverterdataloaders.processors.ArduinoFileProcessor;
import nl.mk.jsunnyreports.loaders.inverterdataloaders.processors.SunnyDataControlXLSFileProcessor;

import org.apache.log4j.Logger;

/**
 * SDCXLSDataLoader.java
 * 
 * Reads Sunnybeam classic files ( SDM and SDT ), generated by Sunny Data Control.
 *
 * @author    Martin Kleinman ( martin@familie-kleinman.nl )
 * @version   2.7.0
 * @since     0.0.0.1
 */

public class SDCXLSDataLoader extends BaseLoader implements LoaderInterface {

    private static final Logger log = Logger.getLogger(SDCXLSDataLoader.class);
    
    private SunnyDataControlXLSInverter inverter;

    public SDCXLSDataLoader(SunnyDataControlXLSInverter inverter, InverterData inverterData, Files fileCache, Settings s) {
        super(inverter, inverterData, fileCache, s);
        this.inverter = inverter;
    }

    /**
     * Removes an SDM* file from the set in memory by parsing the file, getting the date
     * and remove it using the date.
     * 
     * @param sdmFile the XLS, SDM file to remove.
     */
    private void SunnyBeamSDMFileRemove(File sdmFile) {
       /*
        * There is no need to pass the serialnumber of the inverter in here
        * As a month file is reloaded we can assume that both inverters need to be reloaded regardless of their serial.
        */
        inverterData.setUpdated(true);
        int lineNumber = 0;
        try {
            Workbook workbook = Workbook.getWorkbook(sdmFile);
            Sheet sheet = workbook.getSheet( 0 );

            // our life/work starts at row 8
            // get the date and year for this SDM file and then remove all those data from the structure and reload the SDM file.
            Cell timeEntry = sheet.getCell(0, 7);
            DateCell dateCell = (DateCell)timeEntry;
            Calendar cal = Calendar.getInstance(Constants.getLocalTimeZone());
            cal.setTime(dateCell.getDate());

            // remove the whole month from the set for this inverter.
            inverterData.removeMonthFromSet(baseInverter, cal);

        } catch (IOException IOe) {
            log.error("An error has occured reading line: " + lineNumber + " in file: " + sdmFile.getName());
        } catch (BiffException be) {
            log.error("Error processing " + sdmFile.getName() + ". Message: " + be.getMessage());
        }
    }

    /**
     *
     * This method loads a specific SDT file containing a date + yield field and process
     * those into the datastructure.
     *
     * @param sdtFile SDTFile ( Excel ) to process
     * @param init [true/false] depending if the cache is invalid
     * @param year the year to process 
     */
    private void SunnyBeamSDTFileLoad(File sdtFile, boolean init, Integer year ) {
        inverterData.setUpdated(true);
        int lineNumber = 0;
        try {
            Workbook workbook = Workbook.getWorkbook(sdtFile);
           
            // first we have to check in which column we can find the right information for this inverter ( using the serialnr )
            Sheet sheet = workbook.getSheet(0);
            int serialColumn = getSerialColumn(sheet, inverter.getM_SerialNumber() + "");

            String dateFormatInFile = "dd/MM/yyyy HH:mm:ss";
            SimpleDateFormat format = new SimpleDateFormat(dateFormatInFile);
            format.setTimeZone(Constants.getLocalTimeZone());

            for (int iterator = 7; iterator < sheet.getRows(); iterator++) {
                lineNumber = iterator;
                Cell timeEntry = sheet.getCell(0, iterator);
               
                Cell kwhEntry = sheet.getCell(serialColumn, iterator);
                
                if (!"".equals(kwhEntry.getContents())) {

                    try {
                        Calendar cal = Calendar.getInstance(Constants.getLocalTimeZone());
                        cal.setTime(format.parse(timeEntry.getContents()));
                        
                        if ( init ) {
                            inverterData.addInitYearSet( cal );    
                        } else {
                            float kwh = Float.valueOf(kwhEntry.getContents().replace(",", "."));
                            int wh = (int)(kwh * 1000);
                            inverterData.addDayYieldForInverter(cal.get( Calendar.YEAR), cal.get( Calendar.MONTH ) + 1, cal.get( Calendar.DAY_OF_MONTH), baseInverter, wh, year );
                            
                        }


                    } catch (ParseException pe) {
                        log.error("ParseException on line: " + lineNumber + ". I cannot process \"" + timeEntry.getContents() + "\" as a correct date. ");
                    }

                }
            }
        } catch (IOException IOe) {
            log.error("An error has occured reading line: " + lineNumber + " in file: " + sdtFile.getName());
        } catch (BiffException be) {
            log.error("Error processing " + sdtFile.getName() + ". Message: " + be.getMessage());
        }
    }

    /**
     *
     * This method loads the SDT_ma file into the datastructure.
     *
     * @param manualFile SDT_ma.xls File ( Excel ) to process
     * @param init [true/false] depending if the cache is invalid
     * @param year the year to process 
     */
    public void manualFileLoad(File manualFile, boolean init, Integer year ) {
        inverterData.setUpdated(true);
        int lineNumber = 0;
        try {
            Workbook workbook = Workbook.getWorkbook(manualFile);
            Sheet sheet = workbook.getSheet(0);

            for (int iterator = 7; iterator < sheet.getRows(); iterator++) {
                lineNumber = iterator;
                Cell kwhEntry = sheet.getCell(1, iterator);

                if (!"".equals(kwhEntry.getContents())) {
                    Cell timeEntry = sheet.getCell(0, iterator);

                    DateCell dateCell = (DateCell)timeEntry;
                    Calendar cal = Calendar.getInstance(Constants.getLocalTimeZone());
                    cal.setTime(dateCell.getDate());
                    
                    if ( init ) {
                        inverterData.addInitYearSet( cal );    
                    } else {
                        float kWh = new Float(kwhEntry.getContents().replace(",", ".")).floatValue();
                        int wh = (int)(kWh * 1000);
                        inverterData.addDayYieldForInverter(cal.get( Calendar.YEAR), cal.get( Calendar.MONTH ) + 1, cal.get( Calendar.DAY_OF_MONTH), baseInverter, wh, year );
                        
                    }
                    

                }
            }
        } catch (IOException IOe) {
            log.error("An error has occured reading line: " + lineNumber + " in file: " + manualFile.getName());
        } catch (BiffException be) {
            log.error("Error processing " + manualFile.getName() + ". Message: " + be.getMessage());
        }
    }

    /**
     *
     * This method loads the SDT_ma file into the datastructure.
     *
     * @param manualFile SDT_ma.xls File ( Excel ) to process
     */
    public void manualFileRemove(File manualFile) {
        inverterData.setUpdated(true);
        int lineNumber = 0;
        try {
            Workbook workbook = Workbook.getWorkbook(manualFile);
            Sheet sheet = workbook.getSheet(0);

            for (int iterator = 7; iterator < sheet.getRows(); iterator++) {
                lineNumber = iterator;
                Cell kwhEntry = sheet.getCell(1, iterator);

                if (!"".equals(kwhEntry.getContents())) {
                    Cell timeEntry = sheet.getCell(0, iterator);

                    DateCell dateCell = (DateCell)timeEntry;
                    Calendar cal = Calendar.getInstance(Constants.getLocalTimeZone());
                    cal.setTime(dateCell.getDate());

                    inverterData.removeDayFromSet(baseInverter, cal);
                }
            }
        } catch (IOException IOe) {
            log.error("An error has occured reading line: " + lineNumber + " in file: " + manualFile.getName());
        } catch (BiffException be) {
            log.error("Error processing " + manualFile.getName() + ". Message: " + be.getMessage());
        }
    }

    /**
     *
     * @param init [true/false] depending if the cache is invalid
     * @param year the year to process 
     */
    private void process_SDM_Files( boolean init, Integer year ) {
        FileEntries fe = this.processFiles(new StartsWithFilenameFilter("SDM_"), true );

        ExecutorService executor = Executors.newFixedThreadPool(1);
        for ( FileEntry f: fe.getFileList() ) {
            File newFile = new File( f.getFileLocation() );
            if ( f.isToDelete() ) {
                this.SunnyBeamSDMFileRemove(newFile);
            }
            if ( f.isToLoad() ) {
                Runnable fileData = new SunnyDataControlXLSFileProcessor(newFile, inverterData, inverter, settings, init, year,f.getFc()  );
                executor.execute(fileData);
            }

        }    
        executor.shutdown();
        while (!executor.isTerminated()) {
        }        
    }

    /**
     *
     * @param init [true/false] depending if the cache is invalid
     * @param year the year to process  
     */
    private void process_SDT_Files( boolean init, Integer year ) {
        FileEntries fe = this.processFiles(new RegularExpressionFilenameFilter("^SDT((?!_ma).)+\\.xls$"), true );

        ExecutorService executor = Executors.newFixedThreadPool(readThreadCount);
        for ( FileEntry f: fe.getFileList() ) {
            File newFile = new File( f.getFileLocation() );
            // exception to the rule,
            // SDT files don't need to be removed, just loaded.
            if ( f.isToLoad() ) {
                this.SunnyBeamSDTFileLoad(newFile, init, year);
            }
        }    
        executor.shutdown();
        while (!executor.isTerminated()) {
        }        
    }

    /**
     *
     * @param init [true/false] depending if the cache is invalid
     * @param year the year to process 
     */
    private void process_Manual_File( boolean init, Integer year  ) {
        FileEntries fe = this.processFiles(new StartsWithFilenameFilter("SDT_ma"), true );

        ExecutorService executor = Executors.newFixedThreadPool(readThreadCount);
        for ( FileEntry f: fe.getFileList() ) {
            File newFile = new File( f.getFileLocation() );
            if ( f.isToDelete() ) {
                this.manualFileRemove(newFile);
            }
            if ( f.isToLoad() ) {
                this.manualFileLoad(newFile, init, year);
            }

        }    
        executor.shutdown();
        while (!executor.isTerminated()) {
        }                
    }
    
   /**
    *
    *
    * @param   sheet Worksheet ( Excel )
    * @return  the # of the column containing the right serialNr for this inverter.
    */
   private int getSerialColumn(Sheet sheet, String serialnumber) {
       int serialColumn = 0;

       // first we have to check in what column the Watt information is residing.
       for (int iterator = 1; iterator < sheet.getColumns(); iterator++) {
           // JXL works from 0.
           // tested in two SDT files. position to find serial is from col 2 and row 7. 
           Cell testEntry = sheet.getCell(iterator, 6);
           String testString = testEntry.getContents();
           if (serialnumber.equals(testString)) {
               serialColumn = iterator;
               break;
           }
       }
       return serialColumn;
   }    

    /**
     * This method is the start of the loading process. It will read all the information
     * and store it for this baseInverter in the dataset.
     *
     * In this case SDM*.xls and SDT*.xls files.
     *
     * @param init [true/false] depending if the cache is invalid
     * @param year the year to process 
     */
    @Override
    public void dataLoader( boolean init, Integer year ) {
        this.process_SDM_Files( init, year );
        this.process_SDT_Files( init, year );
        this.process_Manual_File( init, year );
        
        /**
         * Possible bug here. My guess is that manual.xls files are processed twice for every SB classic inverter.
         */
        super.dataLoader( init, year );
    }
    
    

}
